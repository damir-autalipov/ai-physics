<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ИИ - лабораторный помощник (U,I,R / L,T / t,h / Custom)</title>

<!-- libs -->
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>

<style>
:root{
  --bg:#f5f6f8;--card:#ffffff;--muted:#6b7280;--text:#0f1724;
  --accent:#2563eb;--accent2:#7c3aed;--good:#16a34a;--warn:#f59e0b;--bad:#dc2626;
  --border:#e6e9ee;
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text);padding:28px;display:flex;justify-content:center}
.wrap{width:100%;max-width:1200px}
header{display:flex;gap:14px;align-items:center;margin-bottom:16px}
.logo{width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,var(--accent2),var(--accent));color:white;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:20px}
h1{margin:0;font-size:20px}
p.lead{margin:0;color:var(--muted);font-size:13px}
.grid{display:grid;grid-template-columns:380px 1fr;gap:18px}
.panel{background:var(--card);border-radius:10px;padding:16px;border:1px solid var(--border);box-shadow:0 6px 18px rgba(15,23,36,0.04)}
.label-row{display:flex;justify-content:space-between;align-items:center}
.exp-card{display:flex;gap:10px;align-items:center;padding:10px;border-radius:8px;border:1px solid #f0f2f6;cursor:pointer;margin-top:8px}
.exp-card.active{border-color:rgba(37,99,235,0.18);box-shadow:0 6px 20px rgba(37,99,235,0.06);background:#f5f8ff}
.exp-icon{width:44px;height:44px;border-radius:8px;background:linear-gradient(135deg,var(--accent),var(--accent2));color:white;display:flex;align-items:center;justify-content:center;font-weight:700}
label{display:block;margin-top:10px;font-weight:600;color:var(--text);font-size:13px}
textarea.input, input.text {width:100%;padding:10px;border-radius:8px;border:1px solid var(--border);margin-top:8px;font-size:14px;background:#fff}
.small-muted{color:var(--muted);font-size:13px}
.row{display:flex;gap:8px;align-items:center}
.btn{padding:10px 12px;border-radius:8px;border:0;background:var(--accent);color:white;cursor:pointer;font-weight:600}
.btn.ghost{background:transparent;border:1px solid var(--border);color:var(--muted)}
.hint{color:var(--muted);font-size:13px;margin-top:8px}
.card-plot{background:var(--card);padding:12px;border-radius:10px;border:1px solid var(--border);box-shadow:0 6px 18px rgba(15,23,36,0.03)}
#plot{width:100%;height:420px}
.pill{background:#f8fafc;border-radius:10px;padding:8px 12px;border:1px solid var(--border);font-weight:600;color:var(--text)}
table.models{width:100%;border-collapse:collapse;margin-top:10px;font-size:13px}
table.models th, table.models td{border:1px solid var(--border);padding:8px;text-align:left}
table.models th{background:#fafafa}
.tooltip{position:relative;display:inline-block}
.tooltip .tooltiptext{visibility:hidden;background:#333;color:#fff;border-radius:6px;padding:8px 10px;position:absolute;z-index:10;bottom:125%;left:50%;transform:translateX(-50%);opacity:0;transition:opacity .2s;width:260px;font-size:12px}
.tooltip:hover .tooltiptext{visibility:visible;opacity:1}
.match-badge{font-weight:700}
footer{margin-top:10px;color:var(--muted);font-size:13px;text-align:center}
@media (max-width:980px){.grid{grid-template-columns:1fr} .panel{order:2}}
.info-small{font-size:12px;color:var(--muted)}
.info-inline{font-size:13px;color:var(--muted);margin-left:6px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo">AI</div>
      <div>
        <h1>ИИ - лабораторный помощник</h1>
        <p class="lead">Выбирай эксперимент → заполняй поля → получай эмпирическую модель, теорию и таблицу сравнения.</p>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT -->
      <div class="panel">
        <div class="label-row">
          <strong>Эксперимент</strong>
          <span class="small-muted">Демо — можно редактировать</span>
        </div>

        <div style="margin-top:12px;display:flex;flex-direction:column;gap:8px">
          <div class="exp-card active" data-mode="ohm" id="card-ohm"><div class="exp-icon">Ω</div><div><div style="font-weight:700">Закон Ома (U, I, R)</div><div class="small-muted">3 поля: U, I, R</div></div></div>
          <div class="exp-card" data-mode="pendulum" id="card-pend"><div class="exp-icon">⏱</div><div><div style="font-weight:700">Маятник (L, T)</div><div class="small-muted">2 поля: L, T</div></div></div>
          <div class="exp-card" data-mode="fall" id="card-fall"><div class="exp-icon">⬇️</div><div><div style="font-weight:700">Свободное падение (t, h)</div><div class="small-muted">2 поля: t, h</div></div></div>
          <div class="exp-card" data-mode="custom" id="card-custom"><div class="exp-icon">✳️</div><div><div style="font-weight:700">Новая зависимость (X, Y)</div><div class="small-muted">2 поля: X, Y</div></div></div>
        </div>

        <div id="inputsArea" style="margin-top:12px;">
          <!-- dynamic inputs inserted here -->
        </div>

        <div style="display:flex;gap:8px;margin-top:12px">
          <button class="btn" id="btnAnalyze">Анализировать</button>
          <button class="btn ghost" id="btnExample">Пример</button>
          <button class="btn ghost" id="btnReset">Сброс</button>
        </div>

        <div class="hint" id="metaHint" style="margin-top:12px">Выберите эксперимент и введите данные.</div>
      </div>

      <!-- RIGHT -->
      <div>
        <div class="card-plot panel">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div>
              <div style="font-weight:700" id="resultTitle">Готов к анализу</div>
              <div class="small-muted" id="resultSub">Данные и модели появятся здесь</div>
            </div>
            <div style="display:flex;gap:8px;align-items:center">
              <div class="tooltip">
                <div class="pill" id="pillR2">R² —</div>
                <span class="tooltiptext">R² (коэффициент детерминации) показывает, какая часть вариации объясняется моделью (1 = идеально).</span>
              </div>
              <div class="pill" id="pillError">Δ% —</div>
            </div>
          </div>

          <div id="plot"></div>
        </div>

        <div class="card-plot panel" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px">
            <div style="flex:1">
              <div style="font-weight:700">Результаты</div>
              <div class="info-small" style="margin-top:8px">Эмпирическая формула (лучшая): <span id="bestModelFormula">—</span></div>
              <div class="info-small" style="margin-top:6px">Теоретическая формула: <span id="theoryFormula">—</span></div>
              <div class="info-small" style="margin-top:6px">Совпадение эмпирич. ↔ теор.: <span id="matchPercent" class="match-badge">—</span></div>
            </div>

            <div style="width:420px">
              <div style="font-weight:700">Сравнение моделей</div>
              <table class="models" id="modelsTable" aria-label="Сравнение моделей">
                <thead><tr><th>Модель</th><th>R²</th><th>Совпадение с теорией</th></tr></thead>
                <tbody id="modelsBody"><tr><td colspan="3" style="color:var(--muted)">Нет данных</td></tr></tbody>
              </table>
            </div>
          </div>

          <div id="explanation" style="margin-top:10px;color:var(--muted)"></div>
        </div>

        <footer>Сохраните как <code>index.html</code> и выкладывайте на GitHub Pages.</footer>
      </div>
    </div>
  </div>

<script>
/* ---------- utilities ---------- */
const cards = document.querySelectorAll('.exp-card');
let mode = 'ohm';
cards.forEach(c => c.addEventListener('click', () => {
  cards.forEach(x=>x.classList.remove('active'));
  c.classList.add('active');
  mode = c.dataset.mode;
  renderInputs();
  adaptPlaceholders();
}));

function adaptPlaceholders(){
  const hint = document.getElementById('metaHint');
  if(mode==='ohm') hint.textContent = 'Закон Ома: U (В), I (А), R (Ом). Можно оставить R пустым (будет оценён). График: I(U).';
  else if(mode==='pendulum') hint.textContent = 'Маятник: L (м) и T (с). Теория: T = 2π√(L/g).';
  else if(mode==='fall') hint.textContent = 'Свободное падение: t (с) и h (м). Теория: h = ½·g·t².';
  else hint.textContent = 'Новая зависимость: X и Y (вводите данные вручную или пример).';
}

/* dynamic inputs rendering */
const inputsArea = document.getElementById('inputsArea');

function renderInputs(){
  inputsArea.innerHTML = ''; // clear
  if(mode==='ohm'){
    inputsArea.innerHTML = `
      <label>U (В):</label>
      <textarea id="inputU" class="input" placeholder="Например: 1, 2, 3, 4"></textarea>
      <label>I (А):</label>
      <textarea id="inputI" class="input" placeholder="Например: 0.98, 0.51, 0.34, 0.24"></textarea>
      <label>R (Ом) — (опционально) <span class="info-inline tooltip">ℹ
        <span class="tooltiptext">Если заполнено, теоретическая кривая будет I = U / R. Если пусто — R оценится по данным (a ≈ 1/R).</span>
      </span></label>
      <input id="inputR" class="text" placeholder="Например: 10, 10, 9.9, 10.1 или оставьте пустым">
    `;
  } else if(mode==='pendulum'){
    inputsArea.innerHTML = `
      <label>L (м):</label>
      <textarea id="inputL" class="input" placeholder="Например: 0.1, 0.2, 0.3"></textarea>
      <label>T (с):</label>
      <textarea id="inputT" class="input" placeholder="Например: 0.63, 0.89, 1.09"></textarea>
    `;
  } else if(mode==='fall'){
    inputsArea.innerHTML = `
      <label>t (с):</label>
      <textarea id="inputt" class="input" placeholder="Например: 0.2, 0.4, 0.6"></textarea>
      <label>h (м):</label>
      <textarea id="inputh" class="input" placeholder="Например: 0.02, 0.08, 0.18"></textarea>
    `;
  } else {
    inputsArea.innerHTML = `
      <label>X:</label>
      <textarea id="inputX" class="input" placeholder="Например: 1, 2, 3"></textarea>
      <label>Y:</label>
      <textarea id="inputY" class="input" placeholder="Например: 2.1, 4.0, 5.9"></textarea>
      <label>Теоретическая формула (опционально), например: y = 2*x^2 + 1</label>
      <input id="inputUserFormula" class="text" placeholder="y = 2*x^2 + 1">
    `;
  }
}
renderInputs();
adaptPlaceholders();

function parseSeries(str){
  if(!str) return [];
  const cleaned = String(str).trim().replace(/\r/g,'').split(/[\n;]/).map(s=>s.trim()).join(',');
  const parts = cleaned.split(',').map(s=>s.trim()).filter(s=>s!=='');
  return parts.map(p=>{ const n=parseFloat(p); return isNaN(n)? null : n; }).filter(v=>v!==null);
}

function r2score(y, ypred){
  const meanY = math.mean(y);
  const ssRes = math.sum(y.map((yi,i)=> (yi-ypred[i])**2));
  const ssTot = math.sum(y.map(yi => (yi-meanY)**2));
  if (ssTot === 0) return 1.0;
  return 1 - ssRes/ssTot;
}
function meanRelativeErrorPercent(y, ypred){
  const eps = 1e-9;
  const rel = y.map((yi,i)=> Math.abs(yi - ypred[i]) / Math.max(Math.abs(yi), eps));
  return math.mean(rel) * 100;
}

/* fitting */
function fitLinear(x,y){
  const meanX = math.mean(x), meanY = math.mean(y);
  const num = math.sum(x.map((xi,i)=> (xi-meanX)*(y[i]-meanY)));
  const den = math.sum(x.map(xi=> (xi-meanX)**2));
  const a = den===0?0: num/den;
  const b = meanY - a*meanX;
  const ypred = x.map(xi => a*xi + b);
  return {type:'linear', coeffs:[a,b], ypred, r2:r2score(y,ypred)};
}
function fitQuad(x,y){
  try{
    const X = math.matrix(x.map(xi => [xi*xi, xi, 1]));
    const Y = math.matrix(y);
    const Xt = math.transpose(X);
    const XtX = math.multiply(Xt, X);
    const inv = math.inv(XtX);
    const XtY = math.multiply(Xt, Y);
    const theta = math.multiply(inv, XtY).toArray().flat();
    const [A,B,C] = theta;
    const ypred = x.map(xi => A*xi*xi + B*xi + C);
    return {type:'quad', coeffs:[A,B,C], ypred, r2:r2score(y,ypred)};
  } catch(e){
    return {type:'quad', coeffs:[0,0,0], ypred:x.map(()=>0), r2:-Infinity};
  }
}
function fitExp(x,y){
  if(y.some(yi => yi <= 0)) return {type:'exp', coeffs:[0,0], ypred:x.map(()=>0), r2:-Infinity};
  const lnY = y.map(yi=> Math.log(yi));
  const meanX = math.mean(x), meanLnY = math.mean(lnY);
  const num = math.sum(x.map((xi,i)=> (xi-meanX)*(lnY[i]-meanLnY)));
  const den = math.sum(x.map(xi=> (xi-meanX)**2));
  const p1 = den===0?0: num/den;
  const lnP0 = meanLnY - p1*meanX;
  const p0 = Math.exp(lnP0);
  const ypred = x.map(xi => p0 * Math.exp(p1*xi));
  return {type:'exp', coeffs:[p0,p1], ypred, r2:r2score(y,ypred)};
}
function fitPower(x,y){
  if(x.some(xi=> xi <= 0) || y.some(yi=> yi <= 0)) return {type:'power', coeffs:[0,0], ypred:x.map(()=>0), r2:-Infinity};
  const lnX = x.map(xi=> Math.log(xi));
  const lnY = y.map(yi=> Math.log(yi));
  const meanLnX = math.mean(lnX), meanLnY = math.mean(lnY);
  const num = math.sum(lnX.map((xi,i)=> (xi-meanLnX)*(lnY[i]-meanLnY)));
  const den = math.sum(lnX.map(xi=> (xi-meanLnX)**2));
  const b = den===0?0: num/den;
  const lnA = meanLnY - b*meanLnX;
  const a = Math.exp(lnA);
  const ypred = x.map(xi => a * Math.pow(xi,b));
  return {type:'power', coeffs:[a,b], ypred, r2:r2score(y,ypred)};
}
function fitLog(x,y){
  if(x.some(xi=> xi <= 0)) return {type:'log', coeffs:[0,0], ypred:x.map(()=>0), r2:-Infinity};
  const lnX = x.map(xi=> Math.log(xi));
  const meanLnX = math.mean(lnX), meanY = math.mean(y);
  const num = math.sum(lnX.map((xi,i)=> (xi-meanLnX)*(y[i]-meanY)));
  const den = math.sum(lnX.map(xi=> (xi-meanLnX)**2));
  const a = den===0?0: num/den;
  const b = meanY - a*meanLnX;
  const ypred = x.map(xi => a*Math.log(xi) + b);
  return {type:'log', coeffs:[a,b], ypred, r2:r2score(y,ypred)};
}

function formulaText(model, vars){
  const X = vars.x, Y = vars.y;
  if(!model) return '—';
  if(model.type==='linear'){ const [a,b]=model.coeffs; return `${Y} = ${a.toFixed(4)}·${X} ${b>=0?'+':'-'} ${Math.abs(b).toFixed(4)}`; }
  if(model.type==='quad'){ const [A,B,C]=model.coeffs; return `${Y} = ${A.toFixed(4)}·${X}² ${B>=0?'+':'-'} ${Math.abs(B).toFixed(4)}·${X} ${C>=0?'+':'-'} ${Math.abs(C).toFixed(4)}`; }
  if(model.type==='exp'){ const [p0,p1]=model.coeffs; return `${Y} = ${p0.toFixed(4)}·e^{${p1.toFixed(4)}·${X}}`; }
  if(model.type==='power'){ const [a,b]=model.coeffs; return `${Y} = ${a.toFixed(4)}·${X}^{${b.toFixed(4)}}`; }
  if(model.type==='log'){ const [a,b]=model.coeffs; return `${Y} = ${a.toFixed(4)}·ln(${X}) ${b>=0?'+':'-'} ${Math.abs(b).toFixed(4)}`; }
  return '—';
}

/* ------- events ------- */
document.getElementById('btnExample').addEventListener('click', loadExample);
document.getElementById('btnAnalyze').addEventListener('click', runAnalysis);
document.getElementById('btnReset').addEventListener('click', resetAll);

function loadExample(){
  if(mode==='ohm'){
    document.getElementById('inputU').value = '1,2,3,4,5';
    document.getElementById('inputI').value = '0.98,0.51,0.34,0.24,0.19';
    document.getElementById('inputR').value = '';
  } else if(mode==='pendulum'){
    document.getElementById('inputL').value = '0.1,0.2,0.3,0.4,0.5';
    document.getElementById('inputT').value = '0.63,0.89,1.09,1.26,1.41';
  } else if(mode==='fall'){
    document.getElementById('inputt').value = '0.2,0.4,0.6,0.8,1.0';
    document.getElementById('inputh').value = '0.2,0.8,1.8,3.2,5.0';
  } else {
    document.getElementById('inputX').value = '1,2,3,4,5';
    document.getElementById('inputY').value = '2.1,4.0,5.9,8.3,10.0';
    document.getElementById('inputUserFormula') && (document.getElementById('inputUserFormula').value = '');
  }
}

function resetAll(){
  renderInputs();
  adaptPlaceholders();
  Plotly.purge('plot');
  document.getElementById('resultTitle').textContent = 'Готов к анализу';
  document.getElementById('resultSub').textContent = 'Данные и модели появятся здесь';
  document.getElementById('bestModelFormula').textContent = '—';
  document.getElementById('theoryFormula').textContent = '—';
  document.getElementById('matchPercent').textContent = '—';
  document.getElementById('modelsBody').innerHTML = '<tr><td colspan="3" style="color:var(--muted)">Нет данных</td></tr>';
  document.getElementById('pillR2').textContent='R² —';
  document.getElementById('pillError').textContent='Δ% —';
  document.getElementById('explanation').textContent='';
}

/* ------- main analysis ------- */
function runAnalysis(){
  // read inputs depending on mode
  let x = [], y = [], extra = null, userFormula = '';
  if(mode==='ohm'){
    x = parseSeries(document.getElementById('inputU').value);
    y = parseSeries(document.getElementById('inputI').value);
    const rRaw = document.getElementById('inputR').value.trim();
    extra = rRaw? parseSeries(rRaw) : null; // array of R values or null
    // require same lengths
    if(x.length !== y.length){ alert('Длины U и I должны совпадать.'); return; }
    if(extra && extra.length !== x.length){ alert('Если вводите R как ряд, его длина должна совпадать с U и I.'); return; }
    if(x.length < 3){ alert('Нужно минимум 3 точки.'); return; }
  } else if(mode==='pendulum'){
    x = parseSeries(document.getElementById('inputL').value);
    y = parseSeries(document.getElementById('inputT').value);
    if(x.length !== y.length){ alert('Длины L и T должны совпадать.'); return; }
    if(x.length < 3){ alert('Нужно минимум 3 точки.'); return; }
  } else if(mode==='fall'){
    x = parseSeries(document.getElementById('inputt').value);
    y = parseSeries(document.getElementById('inputh').value);
    if(x.length !== y.length){ alert('Длины t и h должны совпадать.'); return; }
    if(x.length < 3){ alert('Нужно минимум 3 точки.'); return; }
  } else {
    x = parseSeries(document.getElementById('inputX').value);
    y = parseSeries(document.getElementById('inputY').value);
    userFormula = document.getElementById('inputUserFormula')? document.getElementById('inputUserFormula').value.trim() : '';
    if(x.length !== y.length){ alert('Длины X и Y должны совпадать.'); return; }
    if(x.length < 3){ alert('Нужно минимум 3 точки.'); return; }
  }

  // variable names for display
  let vars = {x:'x', y:'y'};
  if(mode==='ohm') vars = {x:'U', y:'I'};
  else if(mode==='pendulum') vars = {x:'L', y:'T'};
  else if(mode==='fall') vars = {x:'t', y:'h'};
  else vars = {x:'X', y:'Y'};

  // Fit candidate models
  const models = [];
  const m_lin = fitLinear(x,y); models.push({name:'Линейная', model:m_lin});
  const m_quad = fitQuad(x,y); models.push({name:'Квадратичная', model:m_quad});
  const m_power = fitPower(x,y); models.push({name:'Степенная', model:m_power});
  const m_exp = fitExp(x,y); models.push({name:'Экспоненциальная', model:m_exp});
  const m_log = fitLog(x,y); models.push({name:'Логарифмическая', model:m_log});

  // Prepare namedModels array with r2 and ypred
  const namedModels = models.map(m => {
    const r = (m.model && typeof m.model.r2 === 'number') ? m.model.r2 : -Infinity;
    return {name:m.name, type: m.model.type, coeffs: m.model.coeffs, ypred: m.model.ypred, r2: r};
  });

  // select best by R²
  const valid = namedModels.filter(m=>isFinite(m.r2));
  const best = valid.length ? valid.reduce((a,b)=>a.r2>=b.r2?a:b) : namedModels[0];

  // theoretical model (produce y_theory on x)
  let theoryText = '—';
  let y_theory = [];
  if(mode==='ohm'){
    // If user provided R series, use elementwise R to compute theoretical I = U / R_given
    if(extra && extra.length === x.length){
      y_theory = x.map((Ux,i)=> Ux / extra[i]);
      theoryText = 'I = U / R (используется введённый ряд R)';
    } else {
      // estimate R from linear fit: ideal I = (1/R) * U  => slope a = 1/R
      const slope = (m_lin.coeffs && m_lin.coeffs[0]!==undefined) ? m_lin.coeffs[0] : m_lin.a;
      const intercept = (m_lin.coeffs && m_lin.coeffs[1]!==undefined) ? m_lin.coeffs[1] : m_lin.b;
      const R_est = Math.abs(slope) > 1e-12 ? 1 / slope : Infinity;
      // Build theoretical I = U / R_est (if intercept non-negligible, show it)
      y_theory = x.map(Ux => isFinite(R_est) ? Ux / R_est : 0);
      theoryText = `I ≈ U / R, оценка R ≈ ${isFinite(R_est)?R_est.toFixed(4)+' Ω':'—'} (получена из линейной аппроксимации I(U))`;
    }
  } else if(mode==='pendulum'){
    const T2 = y.map(yi => yi*yi);
    const linT2 = fitLinear(x, T2);
    const s = linT2.coeffs ? linT2.coeffs[0] : linT2.a;
    const g = Math.abs(s) > 1e-12 ? (4*Math.PI*Math.PI) / s : NaN;
    y_theory = x.map(L => isFinite(g) ? 2*Math.PI*Math.sqrt(L/g) : 0);
    theoryText = `T = 2π√(L/g), оценка g ≈ ${isFinite(g)?g.toFixed(4)+' м/с²':'—'}`;
  } else if(mode==='fall'){
    const t2 = x.map(tt => tt*tt);
    const linH = fitLinear(t2, y);
    const s = linH.coeffs ? linH.coeffs[0] : linH.a;
    const g = 2*s;
    y_theory = x.map(tt => 0.5 * g * tt * tt);
    theoryText = `h = ½·g·t², оценка g ≈ ${isFinite(g)?g.toFixed(4)+' м/с²':'—'}`;
  } else {
    if(userFormula){
      let expr = userFormula;
      if(expr.includes('=')) expr = expr.split('=').slice(1).join('=');
      expr = expr.trim();
      try{
        const node = math.parse(expr);
        const code = node.compile();
        y_theory = x.map(xx => Number(code.evaluate({x:xx})));
        theoryText = `Пользовательская формула: y = ${expr}`;
      } catch(e){
        y_theory = [];
        theoryText = 'Пользовательская формула: ошибка разбора';
      }
    } else {
      y_theory = [];
      theoryText = '—';
    }
  }

  // Compute matches for each model vs theory (if theory exists)
  const resultsForTable = namedModels.map(m=>{
    let match = null;
    if(y_theory && y_theory.length === x.length && isFinite(m.r2)){
      if(m.ypred && m.ypred.length === x.length){
        const mre = meanRelativeErrorPercent(y_theory, m.ypred); // percent
        match = Math.max(0, 100 - mre);
      }
    }
    return {...m, match};
  });

  // Fill models table
  const tbody = document.getElementById('modelsBody');
  tbody.innerHTML = '';
  resultsForTable.forEach(m=>{
    const tr = document.createElement('tr');
    const tdName = document.createElement('td'); tdName.textContent = m.name;
    const tdR2 = document.createElement('td'); tdR2.textContent = isFinite(m.r2)? m.r2.toFixed(4) : '—';
    const tdMatch = document.createElement('td');
    if(m.match === null || m.match === undefined || Number.isNaN(m.match)) tdMatch.textContent = '—';
    else {
      const span = document.createElement('span');
      span.textContent = m.match.toFixed(2) + '%';
      if(m.match > 90) span.style.color = 'var(--good)';
      else if(m.match > 70) span.style.color = 'var(--warn)';
      else span.style.color = 'var(--bad)';
      tdMatch.appendChild(span);
    }
    tr.appendChild(tdName); tr.appendChild(tdR2); tr.appendChild(tdMatch);
    tbody.appendChild(tr);
  });

  // Best model formula text
  const bestModelObj = {type: best.type, coeffs: best.coeffs};
  const bestFormula = formulaText(bestModelObj, vars);
  document.getElementById('bestModelFormula').textContent = `${best.name}: ${bestFormula}`;

  // theory text
  document.getElementById('theoryFormula').textContent = theoryText;

  // match for best vs theory
  let matchBestText = '—', matchBestValue = null;
  if(y_theory && y_theory.length === x.length && best && best.ypred){
    const mre = meanRelativeErrorPercent(y_theory, best.ypred);
    matchBestValue = Math.max(0, 100 - mre);
    matchBestText = matchBestValue.toFixed(2) + '%';
  }
  const matchEl = document.getElementById('matchPercent');
  matchEl.textContent = matchBestText;
  if(matchBestValue !== null){
    if(matchBestValue > 90) matchEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--good');
    else if(matchBestValue > 70) matchEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--warn');
    else matchEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--bad');
  } else matchEl.style.color = 'inherit';

  // Prepare traces: experiment points (I vs U if ohm -> x axis = U, y axis = I)
  let plotX = x.slice(), plotY = y.slice();
  let xLabel = vars.x, yLabel = vars.y;
  // For plotting smooth best and theory, build grid
  const minX = Math.min(...x), maxX = Math.max(...x);
  const step = (maxX - minX) / 200 || 0.1;
  const grid = math.range(minX, maxX, step, true).toArray();

  // Best model grid values
  let bestGrid = [];
  if(best){
    if(best.type === 'linear'){
      const [a,b] = best.coeffs;
      bestGrid = grid.map(gx => a*gx + b);
    } else if(best.type === 'quad'){
      const [A,B,C] = best.coeffs;
      bestGrid = grid.map(gx => A*gx*gx + B*gx + C);
    } else if(best.type === 'power'){
      const [a,b] = best.coeffs;
      bestGrid = grid.map(gx => a * Math.pow(gx, b));
    } else if(best.type === 'exp'){
      const [p0,p1] = best.coeffs;
      bestGrid = grid.map(gx => p0 * Math.exp(p1*gx));
    } else if(best.type === 'log'){
      const [a,b] = best.coeffs;
      bestGrid = grid.map(gx => a * Math.log(gx) + b);
    } else bestGrid = [];
  }

  // Theory grid
  let theoryGrid = [];
  if(y_theory && y_theory.length === x.length){
    if(mode==='ohm'){
      // If R series provided, theory is U / R_i -> cannot produce continuous grid easily; use average R or estimated R
      if(extra && extra.length === x.length){
        // compute average R for smooth curve
        const Ravg = math.mean(extra);
        theoryGrid = grid.map(gx => gx / Ravg);
      } else {
        // use estimated R from linear slope
        const slope = (m_lin.coeffs && m_lin.coeffs[0]!==undefined) ? m_lin.coeffs[0] : m_lin.a;
        const R_est = Math.abs(slope) > 1e-12 ? 1/slope : Infinity;
        theoryGrid = grid.map(gx => isFinite(R_est) ? gx / R_est : NaN);
      }
    } else if(mode==='pendulum'){
      const T2 = y.map(yi => yi*yi);
      const linT2 = fitLinear(x, T2);
      const s = linT2.coeffs ? linT2.coeffs[0] : linT2.a;
      const g = Math.abs(s) > 1e-12 ? (4*Math.PI*Math.PI) / s : NaN;
      theoryGrid = grid.map(gx => isFinite(g) ? 2*Math.PI*Math.sqrt(gx/g) : NaN);
    } else if(mode==='fall'){
      const t2 = x.map(tt => tt*tt);
      const linH = fitLinear(t2, y);
      const s = linH.coeffs ? linH.coeffs[0] : linH.a;
      const g = 2*s;
      theoryGrid = grid.map(gx => 0.5 * g * gx * gx);
    } else {
      // custom: evaluate user formula on grid if exists
      if(userFormula){
        let expr = userFormula;
        if(expr.includes('=')) expr = expr.split('=').slice(1).join('=');
        expr = expr.trim();
        try{
          const node = math.parse(expr);
          const code = node.compile();
          theoryGrid = grid.map(gx => Number(code.evaluate({x:gx})));
        } catch(e){
          theoryGrid = [];
        }
      }
    }
  }

  // traces: experiment points, best model (grid), theory (grid)
  const traces = [
    {x: plotX, y: plotY, mode:'markers', name:'Эксперимент', marker:{color:'#2563eb',size:8}}
  ];
  if(bestGrid.length) traces.push({x: grid, y: bestGrid, mode:'lines', name:'Лучшая модель', line:{color:'#7c3aed',width:3}});
  if(theoryGrid.length) traces.push({x: grid, y: theoryGrid, mode:'lines', name:'Теоретическая модель', line:{color:'#10b981',dash:'dot',width:3}});
  else if(y_theory.length) traces.push({x: x, y: y_theory, mode:'lines', name:'Теоретическая модель', line:{color:'#10b981',dash:'dot',width:3}});

  Plotly.newPlot('plot', traces, {margin:{t:20,l:60,r:20,b:60}, xaxis:{title:vars.x}, yaxis:{title:vars.y}, legend:{orientation:'h'}});

  // header & pills
  document.getElementById('resultTitle').textContent = 'Анализ завершён';
  document.getElementById('resultSub').textContent = `Лучшая модель: ${best.name} — R²=${isFinite(best.r2)?best.r2.toFixed(4):'—'}`;
  document.getElementById('pillR2').textContent = 'R² = ' + (isFinite(best.r2) ? best.r2.toFixed(4) : '—');
  const errToData = meanRelativeErrorPercent(y, best.ypred);
  document.getElementById('pillError').textContent = 'Δ% = ' + (isFinite(errToData) ? errToData.toFixed(2) + '%' : '—');

  // explanation text
  let expl = `ИИ протестировал 5 типов моделей и выбрал <b>${best.name}</b>, так как у неё наибольшее значение R² (${isFinite(best.r2)?best.r2.toFixed(4):'—'}).`;
  if(y_theory && y_theory.length) expl += ` Подробно показано совпадение каждой модели с теоретической кривой в таблице справа.`;
  document.getElementById('explanation').innerHTML = expl;
}

/* initial example */
loadExample();

</script>
</body>
</html>
